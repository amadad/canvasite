"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-size";
exports.ids = ["vendor-chunks/canvas-size"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-size/dist/canvas-size.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/canvas-size/dist/canvas-size.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ canvasSize)\n/* harmony export */ });\n/*!\n * canvas-size\n * v1.2.6\n * https://github.com/jhildenbiddle/canvas-size\n * (c) 2015-2023 John Hildenbiddle <http://hildenbiddle.com>\n * MIT license\n */\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for (;!(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) ;\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally {\n            try {\n                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n            } finally {\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter((function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        }))), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\n\nfunction _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {\n            _defineProperty(target, key, source[key]);\n        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        }));\n    }\n    return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n}\n\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction canvasTest(settings) {\n    var size = settings.sizes.shift();\n    var width = Math.max(Math.ceil(size[0]), 1);\n    var height = Math.max(Math.ceil(size[1]), 1);\n    var fill = [ width - 1, height - 1, 1, 1 ];\n    var job = Date.now();\n    var isWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n    var cropCvs, testCvs;\n    if (isWorker) {\n        cropCvs = new OffscreenCanvas(1, 1);\n        testCvs = new OffscreenCanvas(width, height);\n    } else {\n        cropCvs = document.createElement(\"canvas\");\n        cropCvs.width = 1;\n        cropCvs.height = 1;\n        testCvs = document.createElement(\"canvas\");\n        testCvs.width = width;\n        testCvs.height = height;\n    }\n    var cropCtx = cropCvs.getContext(\"2d\");\n    var testCtx = testCvs.getContext(\"2d\");\n    if (testCtx) {\n        testCtx.fillRect.apply(testCtx, fill);\n        cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);\n    }\n    var isTestPass = cropCtx && cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;\n    var benchmark = Date.now() - job;\n    [ cropCvs, testCvs ].forEach((function(cvs) {\n        cvs.height = 0;\n        cvs.width = 0;\n    }));\n    if (isWorker) {\n        postMessage({\n            width: width,\n            height: height,\n            benchmark: benchmark,\n            isTestPass: isTestPass\n        });\n        if (!isTestPass && settings.sizes.length) {\n            canvasTest(settings);\n        }\n    } else if (isTestPass) {\n        settings.onSuccess(width, height, benchmark);\n    } else {\n        settings.onError(width, height, benchmark);\n        if (settings.sizes.length) {\n            canvasTest(settings);\n        }\n    }\n    return isTestPass;\n}\n\nvar testSizes = {\n    area: [ 16384, 14188, 11402, 11180, 10836, 8192, 4096, 1 ],\n    height: [ 8388607, 65535, 32767, 16384, 8192, 4096, 1 ],\n    width: [ 4194303, 65535, 32767, 16384, 8192, 4096, 1 ]\n};\n\nvar _excluded = [ \"onError\", \"onSuccess\" ];\n\nvar defaults = {\n    max: null,\n    min: 1,\n    sizes: [],\n    step: 1024,\n    usePromise: false,\n    useWorker: false,\n    onError: Function.prototype,\n    onSuccess: Function.prototype\n};\n\nvar workerJobs = {};\n\nfunction createSizesArray(settings) {\n    var isArea = settings.width === settings.height;\n    var isWidth = settings.height === 1;\n    var isHeight = settings.width === 1;\n    var sizes = [];\n    if (!settings.width || !settings.height) {\n        settings.sizes.forEach((function(testSize) {\n            var width = isArea || isWidth ? testSize : 1;\n            var height = isArea || isHeight ? testSize : 1;\n            sizes.push([ width, height ]);\n        }));\n    } else {\n        var testMin = settings.min || defaults.min;\n        var testStep = settings.step || defaults.step;\n        var testSize = Math.max(settings.width, settings.height);\n        while (testSize >= testMin) {\n            var width = isArea || isWidth ? testSize : 1;\n            var height = isArea || isHeight ? testSize : 1;\n            sizes.push([ width, height ]);\n            testSize -= testStep;\n        }\n    }\n    return sizes;\n}\n\nfunction handleMethod(settings) {\n    var hasCanvasSupport = window && \"HTMLCanvasElement\" in window;\n    var hasOffscreenCanvasSupport = window && \"OffscreenCanvas\" in window;\n    var jobID = Date.now();\n    var _onError = settings.onError, _onSuccess = settings.onSuccess, settingsWithoutCallbacks = _objectWithoutProperties(settings, _excluded);\n    var worker = null;\n    if (!hasCanvasSupport) {\n        return false;\n    }\n    if (settings.useWorker && hasOffscreenCanvasSupport) {\n        var js = \"\\n            var canvasTest = \".concat(canvasTest.toString(), \";\\n            onmessage = function(e) {\\n                canvasTest(e.data);\\n            };\\n        \");\n        var blob = new Blob([ js ], {\n            type: \"application/javascript\"\n        });\n        var blobURL = URL.createObjectURL(blob);\n        worker = new Worker(blobURL);\n        URL.revokeObjectURL(blobURL);\n        worker.onmessage = function(e) {\n            var _e$data = e.data, width = _e$data.width, height = _e$data.height, benchmark = _e$data.benchmark, isTestPass = _e$data.isTestPass;\n            if (isTestPass) {\n                workerJobs[jobID].onSuccess(width, height, benchmark);\n                delete workerJobs[jobID];\n            } else {\n                workerJobs[jobID].onError(width, height, benchmark);\n            }\n        };\n    }\n    if (settings.usePromise) {\n        return new Promise((function(resolve, reject) {\n            var promiseSettings = _objectSpread2(_objectSpread2({}, settings), {}, {\n                onError: function onError(width, height, benchmark) {\n                    var isLastTest;\n                    if (settings.sizes.length === 0) {\n                        isLastTest = true;\n                    } else {\n                        var _settings$sizes$slice = settings.sizes.slice(-1), _settings$sizes$slice2 = _slicedToArray(_settings$sizes$slice, 1), _settings$sizes$slice3 = _slicedToArray(_settings$sizes$slice2[0], 2), lastWidth = _settings$sizes$slice3[0], lastHeight = _settings$sizes$slice3[1];\n                        isLastTest = width === lastWidth && height === lastHeight;\n                    }\n                    _onError(width, height, benchmark);\n                    if (isLastTest) {\n                        reject({\n                            width: width,\n                            height: height,\n                            benchmark: benchmark\n                        });\n                    }\n                },\n                onSuccess: function onSuccess(width, height, benchmark) {\n                    _onSuccess(width, height, benchmark);\n                    resolve({\n                        width: width,\n                        height: height,\n                        benchmark: benchmark\n                    });\n                }\n            });\n            if (worker) {\n                var onError = promiseSettings.onError, onSuccess = promiseSettings.onSuccess;\n                workerJobs[jobID] = {\n                    onError: onError,\n                    onSuccess: onSuccess\n                };\n                worker.postMessage(settingsWithoutCallbacks);\n            } else {\n                canvasTest(promiseSettings);\n            }\n        }));\n    } else {\n        if (worker) {\n            workerJobs[jobID] = {\n                onError: _onError,\n                onSuccess: _onSuccess\n            };\n            worker.postMessage(settingsWithoutCallbacks);\n        } else {\n            return canvasTest(settings);\n        }\n    }\n}\n\nvar canvasSize = {\n    maxArea: function maxArea() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: options.max,\n            height: options.max,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.area)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    maxHeight: function maxHeight() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: 1,\n            height: options.max,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.height)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    maxWidth: function maxWidth() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: options.max,\n            height: 1,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.width)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    test: function test() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var settings = _objectSpread2(_objectSpread2({}, defaults), options);\n        settings.sizes = _toConsumableArray(settings.sizes);\n        if (settings.width && settings.height) {\n            settings.sizes = [ [ settings.width, settings.height ] ];\n        }\n        return handleMethod(settings);\n    }\n};\n\n\n//# sourceMappingURL=canvas-size.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLXNpemUvZGlzdC9jYW52YXMtc2l6ZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyw2RUFBNkU7QUFDdEcsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix1Q0FBdUMscUNBQXFDLGdCQUFnQjtBQUMvSztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNFQUFzRSx5QkFBeUI7QUFDL0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzRUFBc0UseUJBQXlCO0FBQy9GO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0VBQXNFLHlCQUF5QjtBQUMvRjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RyYXctYS11aS8uL25vZGVfbW9kdWxlcy9jYW52YXMtc2l6ZS9kaXN0L2NhbnZhcy1zaXplLmVzbS5qcz84NWQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY2FudmFzLXNpemVcbiAqIHYxLjIuNlxuICogaHR0cHM6Ly9naXRodWIuY29tL2poaWxkZW5iaWRkbGUvY2FudmFzLXNpemVcbiAqIChjKSAyMDE1LTIwMjMgSm9obiBIaWxkZW5iaWRkbGUgPGh0dHA6Ly9oaWxkZW5iaWRkbGUuY29tPlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChudWxsICE9IF9pKSB7XG4gICAgICAgIHZhciBfcywgX2UsIF94LCBfciwgX2FyciA9IFtdLCBfbiA9ICEwLCBfZCA9ICExO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgX24gPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZSBmb3IgKDshKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApIDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZCA9ICEwLCBfZSA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfbiAmJiBudWxsICE9IF9pLnJldHVybiAmJiAoX3IgPSBfaS5yZXR1cm4oKSwgT2JqZWN0KF9yKSAhPT0gX3IpKSByZXR1cm47XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgIH0pKSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIGNhbnZhc1Rlc3Qoc2V0dGluZ3MpIHtcbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLnNpemVzLnNoaWZ0KCk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKHNpemVbMF0pLCAxKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKHNpemVbMV0pLCAxKTtcbiAgICB2YXIgZmlsbCA9IFsgd2lkdGggLSAxLCBoZWlnaHQgLSAxLCAxLCAxIF07XG4gICAgdmFyIGpvYiA9IERhdGUubm93KCk7XG4gICAgdmFyIGlzV29ya2VyID0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZTtcbiAgICB2YXIgY3JvcEN2cywgdGVzdEN2cztcbiAgICBpZiAoaXNXb3JrZXIpIHtcbiAgICAgICAgY3JvcEN2cyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgICAgIHRlc3RDdnMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNyb3BDdnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjcm9wQ3ZzLndpZHRoID0gMTtcbiAgICAgICAgY3JvcEN2cy5oZWlnaHQgPSAxO1xuICAgICAgICB0ZXN0Q3ZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGVzdEN2cy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0ZXN0Q3ZzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdmFyIGNyb3BDdHggPSBjcm9wQ3ZzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB2YXIgdGVzdEN0eCA9IHRlc3RDdnMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICh0ZXN0Q3R4KSB7XG4gICAgICAgIHRlc3RDdHguZmlsbFJlY3QuYXBwbHkodGVzdEN0eCwgZmlsbCk7XG4gICAgICAgIGNyb3BDdHguZHJhd0ltYWdlKHRlc3RDdnMsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSwgMSwgMSwgMCwgMCwgMSwgMSk7XG4gICAgfVxuICAgIHZhciBpc1Rlc3RQYXNzID0gY3JvcEN0eCAmJiBjcm9wQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzNdICE9PSAwO1xuICAgIHZhciBiZW5jaG1hcmsgPSBEYXRlLm5vdygpIC0gam9iO1xuICAgIFsgY3JvcEN2cywgdGVzdEN2cyBdLmZvckVhY2goKGZ1bmN0aW9uKGN2cykge1xuICAgICAgICBjdnMuaGVpZ2h0ID0gMDtcbiAgICAgICAgY3ZzLndpZHRoID0gMDtcbiAgICB9KSk7XG4gICAgaWYgKGlzV29ya2VyKSB7XG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgYmVuY2htYXJrOiBiZW5jaG1hcmssXG4gICAgICAgICAgICBpc1Rlc3RQYXNzOiBpc1Rlc3RQYXNzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzVGVzdFBhc3MgJiYgc2V0dGluZ3Muc2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYW52YXNUZXN0KHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXN0UGFzcykge1xuICAgICAgICBzZXR0aW5ncy5vblN1Y2Nlc3Mod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0aW5ncy5vbkVycm9yKHdpZHRoLCBoZWlnaHQsIGJlbmNobWFyayk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbnZhc1Rlc3Qoc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1Rlc3RQYXNzO1xufVxuXG52YXIgdGVzdFNpemVzID0ge1xuICAgIGFyZWE6IFsgMTYzODQsIDE0MTg4LCAxMTQwMiwgMTExODAsIDEwODM2LCA4MTkyLCA0MDk2LCAxIF0sXG4gICAgaGVpZ2h0OiBbIDgzODg2MDcsIDY1NTM1LCAzMjc2NywgMTYzODQsIDgxOTIsIDQwOTYsIDEgXSxcbiAgICB3aWR0aDogWyA0MTk0MzAzLCA2NTUzNSwgMzI3NjcsIDE2Mzg0LCA4MTkyLCA0MDk2LCAxIF1cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbIFwib25FcnJvclwiLCBcIm9uU3VjY2Vzc1wiIF07XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBtYXg6IG51bGwsXG4gICAgbWluOiAxLFxuICAgIHNpemVzOiBbXSxcbiAgICBzdGVwOiAxMDI0LFxuICAgIHVzZVByb21pc2U6IGZhbHNlLFxuICAgIHVzZVdvcmtlcjogZmFsc2UsXG4gICAgb25FcnJvcjogRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9uU3VjY2VzczogRnVuY3Rpb24ucHJvdG90eXBlXG59O1xuXG52YXIgd29ya2VySm9icyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVTaXplc0FycmF5KHNldHRpbmdzKSB7XG4gICAgdmFyIGlzQXJlYSA9IHNldHRpbmdzLndpZHRoID09PSBzZXR0aW5ncy5oZWlnaHQ7XG4gICAgdmFyIGlzV2lkdGggPSBzZXR0aW5ncy5oZWlnaHQgPT09IDE7XG4gICAgdmFyIGlzSGVpZ2h0ID0gc2V0dGluZ3Mud2lkdGggPT09IDE7XG4gICAgdmFyIHNpemVzID0gW107XG4gICAgaWYgKCFzZXR0aW5ncy53aWR0aCB8fCAhc2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgIHNldHRpbmdzLnNpemVzLmZvckVhY2goKGZ1bmN0aW9uKHRlc3RTaXplKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBpc0FyZWEgfHwgaXNXaWR0aCA/IHRlc3RTaXplIDogMTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBpc0FyZWEgfHwgaXNIZWlnaHQgPyB0ZXN0U2l6ZSA6IDE7XG4gICAgICAgICAgICBzaXplcy5wdXNoKFsgd2lkdGgsIGhlaWdodCBdKTtcbiAgICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXN0TWluID0gc2V0dGluZ3MubWluIHx8IGRlZmF1bHRzLm1pbjtcbiAgICAgICAgdmFyIHRlc3RTdGVwID0gc2V0dGluZ3Muc3RlcCB8fCBkZWZhdWx0cy5zdGVwO1xuICAgICAgICB2YXIgdGVzdFNpemUgPSBNYXRoLm1heChzZXR0aW5ncy53aWR0aCwgc2V0dGluZ3MuaGVpZ2h0KTtcbiAgICAgICAgd2hpbGUgKHRlc3RTaXplID49IHRlc3RNaW4pIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGlzQXJlYSB8fCBpc1dpZHRoID8gdGVzdFNpemUgOiAxO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGlzQXJlYSB8fCBpc0hlaWdodCA/IHRlc3RTaXplIDogMTtcbiAgICAgICAgICAgIHNpemVzLnB1c2goWyB3aWR0aCwgaGVpZ2h0IF0pO1xuICAgICAgICAgICAgdGVzdFNpemUgLT0gdGVzdFN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemVzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNZXRob2Qoc2V0dGluZ3MpIHtcbiAgICB2YXIgaGFzQ2FudmFzU3VwcG9ydCA9IHdpbmRvdyAmJiBcIkhUTUxDYW52YXNFbGVtZW50XCIgaW4gd2luZG93O1xuICAgIHZhciBoYXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ID0gd2luZG93ICYmIFwiT2Zmc2NyZWVuQ2FudmFzXCIgaW4gd2luZG93O1xuICAgIHZhciBqb2JJRCA9IERhdGUubm93KCk7XG4gICAgdmFyIF9vbkVycm9yID0gc2V0dGluZ3Mub25FcnJvciwgX29uU3VjY2VzcyA9IHNldHRpbmdzLm9uU3VjY2Vzcywgc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2tzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNldHRpbmdzLCBfZXhjbHVkZWQpO1xuICAgIHZhciB3b3JrZXIgPSBudWxsO1xuICAgIGlmICghaGFzQ2FudmFzU3VwcG9ydCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy51c2VXb3JrZXIgJiYgaGFzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydCkge1xuICAgICAgICB2YXIganMgPSBcIlxcbiAgICAgICAgICAgIHZhciBjYW52YXNUZXN0ID0gXCIuY29uY2F0KGNhbnZhc1Rlc3QudG9TdHJpbmcoKSwgXCI7XFxuICAgICAgICAgICAgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xcbiAgICAgICAgICAgICAgICBjYW52YXNUZXN0KGUuZGF0YSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIFwiKTtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbIGpzIF0sIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgX2UkZGF0YSA9IGUuZGF0YSwgd2lkdGggPSBfZSRkYXRhLndpZHRoLCBoZWlnaHQgPSBfZSRkYXRhLmhlaWdodCwgYmVuY2htYXJrID0gX2UkZGF0YS5iZW5jaG1hcmssIGlzVGVzdFBhc3MgPSBfZSRkYXRhLmlzVGVzdFBhc3M7XG4gICAgICAgICAgICBpZiAoaXNUZXN0UGFzcykge1xuICAgICAgICAgICAgICAgIHdvcmtlckpvYnNbam9iSURdLm9uU3VjY2Vzcyh3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3b3JrZXJKb2JzW2pvYklEXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0ub25FcnJvcih3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MudXNlUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VTZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzZXR0aW5ncyksIHt9LCB7XG4gICAgICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcih3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTGFzdFRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zaXplcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFzdFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zZXR0aW5ncyRzaXplcyRzbGljZSA9IHNldHRpbmdzLnNpemVzLnNsaWNlKC0xKSwgX3NldHRpbmdzJHNpemVzJHNsaWNlMiA9IF9zbGljZWRUb0FycmF5KF9zZXR0aW5ncyRzaXplcyRzbGljZSwgMSksIF9zZXR0aW5ncyRzaXplcyRzbGljZTMgPSBfc2xpY2VkVG9BcnJheShfc2V0dGluZ3Mkc2l6ZXMkc2xpY2UyWzBdLCAyKSwgbGFzdFdpZHRoID0gX3NldHRpbmdzJHNpemVzJHNsaWNlM1swXSwgbGFzdEhlaWdodCA9IF9zZXR0aW5ncyRzaXplcyRzbGljZTNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xhc3RUZXN0ID0gd2lkdGggPT09IGxhc3RXaWR0aCAmJiBoZWlnaHQgPT09IGxhc3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX29uRXJyb3Iod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGFzdFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlbmNobWFyazogYmVuY2htYXJrXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3Mod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9vblN1Y2Nlc3Mod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlbmNobWFyazogYmVuY2htYXJrXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgICAgIHZhciBvbkVycm9yID0gcHJvbWlzZVNldHRpbmdzLm9uRXJyb3IsIG9uU3VjY2VzcyA9IHByb21pc2VTZXR0aW5ncy5vblN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzVGVzdChwcm9taXNlU2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0gPSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcjogX29uRXJyb3IsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBfb25TdWNjZXNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHNldHRpbmdzV2l0aG91dENhbGxiYWNrcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzVGVzdChzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBjYW52YXNTaXplID0ge1xuICAgIG1heEFyZWE6IGZ1bmN0aW9uIG1heEFyZWEoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHNpemVzID0gY3JlYXRlU2l6ZXNBcnJheSh7XG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5tYXgsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4LFxuICAgICAgICAgICAgbWluOiBvcHRpb25zLm1pbixcbiAgICAgICAgICAgIHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgICAgICAgICAgIHNpemVzOiBfdG9Db25zdW1hYmxlQXJyYXkodGVzdFNpemVzLmFyZWEpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHNpemVzOiBzaXplc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfSxcbiAgICBtYXhIZWlnaHQ6IGZ1bmN0aW9uIG1heEhlaWdodCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgc2l6ZXMgPSBjcmVhdGVTaXplc0FycmF5KHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLm1heCxcbiAgICAgICAgICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBzdGVwOiBvcHRpb25zLnN0ZXAsXG4gICAgICAgICAgICBzaXplczogX3RvQ29uc3VtYWJsZUFycmF5KHRlc3RTaXplcy5oZWlnaHQpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHNpemVzOiBzaXplc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfSxcbiAgICBtYXhXaWR0aDogZnVuY3Rpb24gbWF4V2lkdGgoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHNpemVzID0gY3JlYXRlU2l6ZXNBcnJheSh7XG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5tYXgsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICBtaW46IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgc3RlcDogb3B0aW9ucy5zdGVwLFxuICAgICAgICAgICAgc2l6ZXM6IF90b0NvbnN1bWFibGVBcnJheSh0ZXN0U2l6ZXMud2lkdGgpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHNpemVzOiBzaXplc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgICBzZXR0aW5ncy5zaXplcyA9IF90b0NvbnN1bWFibGVBcnJheShzZXR0aW5ncy5zaXplcyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy53aWR0aCAmJiBzZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNpemVzID0gWyBbIHNldHRpbmdzLndpZHRoLCBzZXR0aW5ncy5oZWlnaHQgXSBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVNZXRob2Qoc2V0dGluZ3MpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGNhbnZhc1NpemUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FudmFzLXNpemUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-size/dist/canvas-size.esm.js\n");

/***/ })

};
;